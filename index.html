<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>INSI Script Overlay</title>
  <style>
    :root{
      --bg-color:#f4f4f9;
      --panel-bg:#ffffff;
      --primary:#007bff;
      --text-color:#333;
      --border-color:#ddd;
      --highlight:#ff0;
      --mp-bg:#c2f0fc;
      --cl-color:#555;
    }
    body{
      font-family:'Segoe UI',sans-serif;
      background:var(--bg-color);
      color:var(--text-color);
      margin:0;
      padding:15px;
    }
    .container{
      max-width:900px;
      margin:auto;
      background:var(--panel-bg);
      padding:20px;
      border-radius:12px;
      box-shadow:0 4px 15px rgba(0,0,0,0.1);
      border:1px solid var(--border-color);
    }
    .tabs{
      display:flex;
      gap:10px;
      margin-bottom:20px;
      border-bottom:2px solid var(--border-color);
      padding-bottom:10px;
      flex-wrap:wrap;
    }
    .tab-btn{
      padding:10px 20px;
      border:none;
      background:#eee;
      cursor:pointer;
      border-radius:8px;
      font-weight:600;
      transition:0.3s;
      user-select:none;
    }
    .tab-btn.active{ background:var(--primary); color:#fff; }
    .tab-content{ display:none; }
    .tab-content.active{ display:block; }

    .search-container{
      margin-bottom:15px;
      display:flex;
      gap:10px;
    }
    input[type="text"], textarea{
      width:100%;
      padding:12px;
      border:1px solid var(--border-color);
      border-radius:8px;
      font-size:16px;
      box-sizing:border-box;
    }
    textarea{
      height:340px;
      font-family:monospace;
      line-height:1.35;
      resize:vertical;
      white-space:pre-wrap;
    }

    /* ВАЖНО: компактнее интервалы */
    .script-box{
      background:#fafafa;
      padding:18px;
      border:1px solid var(--border-color);
      border-radius:8px;
      min-height:300px;
      white-space:pre-wrap;
      font-size:16px;
      line-height:1.35;     /* было 1.6 */
      overflow-wrap:anywhere;
    }

    .highlight{
      background:var(--highlight);
      font-weight:700;
      border-radius:3px;
      padding:0 2px;
    }
    .controls{
      margin-top:15px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .btn{
      padding:10px 18px;
      border:none;
      border-radius:6px;
      cursor:pointer;
      font-weight:700;
      transition:0.2s;
      user-select:none;
    }
    .btn:active{ transform:translateY(1px); }
    .btn-primary{ background:var(--primary); color:#fff; }
    .btn-success{ background:#28a745; color:#fff; }
    .btn-secondary{ background:#6c757d; color:#fff; }

    .hotkeys-info{
      font-size:12px;
      color:#777;
      margin-top:10px;
    }

    /* МП-реплика */
    .mp-line{
      background:var(--mp-bg);
      padding:2px 4px;
      border-radius:3px;
      display:inline;
    }

    /* Клиентская строка: без "К -", но визуально отличаем */
    .cl-line{
      color:var(--cl-color);
    }

    .hint{
      font-size:13px;
      color:#666;
      margin:8px 0 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="tabs">
      <button class="tab-btn active" data-tab="incoming">Входящий (Ctrl+I)</button>
      <button class="tab-btn" data-tab="outgoing">Исходящий (Ctrl+O)</button>
      <button class="tab-btn" data-tab="edit">Редактирование</button>
    </div>

    <div id="incoming" class="tab-content active">
      <div class="search-container">
        <input type="text" id="incoming-search" placeholder="Поиск по фразе..." autocomplete="off">
      </div>
      <div id="incoming-text" class="script-box"></div>
      <div class="controls">
        <button class="btn btn-secondary" data-copy="incoming-text">Копировать всё</button>
      </div>
      <div class="hint">Подсказка: поиск подсвечивает совпадения в отображаемом тексте.</div>
    </div>

    <div id="outgoing" class="tab-content">
      <div class="search-container">
        <input type="text" id="outgoing-search" placeholder="Поиск по фразе..." autocomplete="off">
      </div>
      <div id="outgoing-text" class="script-box"></div>
      <div class="controls">
        <button class="btn btn-secondary" data-copy="outgoing-text">Копировать всё</button>
      </div>
    </div>

    <div id="edit" class="tab-content">
      <h3>Настройка скриптов</h3>

      <p>Входящий скрипт:</p>
      <textarea id="incoming-edit"></textarea>
      <button class="btn btn-success" data-save="incoming">Сохранить входящий</button>

      <p>Исходящий скрипт:</p>
      <textarea id="outgoing-edit"></textarea>
      <button class="btn btn-success" data-save="outgoing">Сохранить исходящий</button>

      <div class="controls">
        <button class="btn btn-primary" id="download-btn">Скачать бэкап (TXT)</button>
        <button class="btn btn-secondary" id="reset-btn">Сбросить к заводским</button>
      </div>

      <div class="hotkeys-info">
        Горячие клавиши: [Ctrl+I] Входящий | [Ctrl+O] Исходящий | Поиск работает мгновенно
      </div>
      <div class="hint">
        Можно хранить скрипт как HTML (например, &lt;span class="mp-line"&gt;...&lt;/span&gt; и &lt;br&gt;)
        или как обычный текст с переносами строк.
      </div>
    </div>
  </div>

<script>
(() => {
  const KEY_IN = "incomingScript";
  const KEY_OUT = "outgoingScript";

  // ======================
  // Заводские скрипты
  // ======================

  // ВХОДЯЩИЙ — НАШ СОГЛАСОВАННЫЙ СТАРТ
  // Интервалы:
  // - между МП и ответом клиента: один <br>
  // - между блоками: <br><br>
  const defaultIncoming =
`<span class="mp-line">Здравствуйте! Компания ИНСИ. Меня зовут Рыкунов Андрей, я руководитель проекта.</span><br>
<span class="mp-line">Подскажите, пожалуйста, как могу к вам обращаться?</span><br>
<span class="cl-line">Сергей</span><br>
<span class="mp-line">Приятно, Сергей, слушаю вас.</span><br>
<span class="cl-line">(Озвучивает запрос)</span><br>
<span class="mp-line">Понял. Чтобы корректно посчитать стоимость и подготовить КП, задам несколько вопросов — удобно?</span><br><br>
<span class="mp-line">Первый вопрос: в каком городе планируете строительство?</span>`;

  // ИСХОДЯЩИЙ — пока оставил нейтральный, чтобы не мешал входящему
  const defaultOutgoing =
`<span class="mp-line">Здравствуйте! Компания ИНСИ. Меня зовут Рыкунов Андрей, я руководитель проекта.</span><br>
<span class="mp-line">Подскажите, пожалуйста, как могу к вам обращаться?</span><br>
<span class="cl-line">(Имя)</span><br>
<span class="mp-line">Вы ранее интересовались быстровозводимыми зданиями — актуально?</span><br>
<span class="cl-line">(Да/нет)</span><br>
<span class="mp-line">Чтобы корректно посчитать стоимость и подготовить КП, задам несколько вопросов — удобно?</span>`;

  // ======================
  // Storage helpers
  // ======================
  function safeStorageGet(key) {
    try { return localStorage.getItem(key); } catch (_) { return null; }
  }
  function safeStorageSet(key, val) {
    try { localStorage.setItem(key, val); return true; } catch (_) { return false; }
  }

  // ======================
  // Utils
  // ======================
  function escapeHtml(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  // Удаляем "К - / К: / К —" только в начале строк (для отображения/копирования)
  function stripClientPrefixInPlainText(s) {
    return String(s).replace(/(^|\n)\s*К\s*[-:—]\s*/gim, "$1");
  }

  function normalizeToHtml(raw) {
    let s = String(raw ?? "");
    s = stripClientPrefixInPlainText(s);

    const looksLikeHtml = /<\/?[a-z][\s\S]*>/i.test(s);
    if (looksLikeHtml) return s;

    // plain text -> html with <br>, plus simple MP markers
    const lines = s.replace(/\r\n/g, "\n").split("\n");
    const out = [];
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) { out.push(""); continue; }

      // "МП - ..." or "[МП] ..."
      const mp1 = trimmed.match(/^МП\s*[-:—]\s*(.*)$/i);
      const mp2 = trimmed.match(/^\[МП\]\s*(.*)$/i);

      if (mp1) out.push(`<span class="mp-line">${escapeHtml(mp1[1])}</span>`);
      else if (mp2) out.push(`<span class="mp-line">${escapeHtml(mp2[1])}</span>`);
      else out.push(`<span class="cl-line">${escapeHtml(line)}</span>`);
    }
    return out.join("<br>");
  }

  // Санитизация: разрешаем только TEXT + <br> + <span class="mp-line"> + <span class="cl-line">
  function buildSafeFragmentFromHtml(html) {
    const wrapper = document.createElement("div");
    wrapper.innerHTML = html;

    const frag = document.createDocumentFragment();

    function walk(node, parentFrag) {
      if (node.nodeType === Node.TEXT_NODE) {
        const cleaned = stripClientPrefixInPlainText(node.nodeValue);
        parentFrag.appendChild(document.createTextNode(cleaned));
        return;
      }
      if (node.nodeType !== Node.ELEMENT_NODE) return;

      const tag = node.tagName.toUpperCase();

      if (tag === "BR") {
        parentFrag.appendChild(document.createElement("br"));
        return;
      }

      if (tag === "SPAN" && node.classList.contains("mp-line")) {
        const span = document.createElement("span");
        span.className = "mp-line";
        span.textContent = stripClientPrefixInPlainText(node.textContent || "");
        parentFrag.appendChild(span);
        return;
      }

      if (tag === "SPAN" && node.classList.contains("cl-line")) {
        const span = document.createElement("span");
        span.className = "cl-line";
        span.textContent = stripClientPrefixInPlainText(node.textContent || "");
        parentFrag.appendChild(span);
        return;
      }

      // Любой другой тег превращаем в текст
      if (node.childNodes && node.childNodes.length) {
        for (const ch of node.childNodes) walk(ch, parentFrag);
      }
    }

    for (const ch of wrapper.childNodes) walk(ch, frag);
    return frag;
  }

  function escapeRegExp(s) {
    return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  function highlightElement(rootEl, query) {
    const q = String(query || "").trim();
    if (!q) return;

    const re = new RegExp(escapeRegExp(q), "gi");
    const walker = document.createTreeWalker(rootEl, NodeFilter.SHOW_TEXT);
    const textNodes = [];
    while (walker.nextNode()) textNodes.push(walker.currentNode);

    for (const tn of textNodes) {
      const text = tn.nodeValue;
      if (!text || !re.test(text)) continue;

      re.lastIndex = 0;
      const parts = [];
      let last = 0;
      let m;
      while ((m = re.exec(text)) !== null) {
        parts.push({ t: text.slice(last, m.index), h: false });
        parts.push({ t: m[0], h: true });
        last = m.index + m[0].length;
        if (m[0].length === 0) break;
      }
      parts.push({ t: text.slice(last), h: false });

      const frag = document.createDocumentFragment();
      for (const p of parts) {
        if (!p.t) continue;
        if (!p.h) frag.appendChild(document.createTextNode(p.t));
        else {
          const span = document.createElement("span");
          span.className = "highlight";
          span.textContent = p.t;
          frag.appendChild(span);
        }
      }
      tn.parentNode.replaceChild(frag, tn);
    }
  }

  function getRaw(type) {
    const key = type === "incoming" ? KEY_IN : KEY_OUT;
    const def = type === "incoming" ? defaultIncoming : defaultOutgoing;
    return safeStorageGet(key) || def;
  }

  function setRaw(type, val) {
    const key = type === "incoming" ? KEY_IN : KEY_OUT;
    return safeStorageSet(key, String(val ?? ""));
  }

  function render(type) {
    const raw = getRaw(type);
    const html = normalizeToHtml(raw);
    const query = document.getElementById(type + "-search")?.value?.trim() || "";

    const box = document.getElementById(type + "-text");
    box.innerHTML = "";
    box.appendChild(buildSafeFragmentFromHtml(html));

    if (query) highlightElement(box, query);
  }

  function loadIntoEditor() {
    const inc = getRaw("incoming");
    const out = getRaw("outgoing");
    document.getElementById("incoming-edit").value = inc;
    document.getElementById("outgoing-edit").value = out;
  }

  function switchTab(name) {
    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
    document.querySelectorAll(".tab-btn").forEach(b => b.classList.remove("active"));

    document.getElementById(name).classList.add("active");
    document.querySelector(`.tab-btn[data-tab="${name}"]`)?.classList.add("active");

    if (name === "incoming") render("incoming");
    if (name === "outgoing") render("outgoing");
    if (name === "edit") loadIntoEditor();
  }

  async function copyBoxText(boxId) {
    const el = document.getElementById(boxId);
    const text = el ? el.innerText : "";

    try {
      if (window.isSecureContext && navigator.clipboard?.writeText) {
        await navigator.clipboard.writeText(text);
      } else {
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
      }
      alert("Скопировано!");
    } catch (e) {
      alert("Не удалось скопировать (проверь HTTPS/права браузера).");
    }
  }

  function downloadAll() {
    const i = getRaw("incoming");
    const o = getRaw("outgoing");
    const blob = new Blob([`INCOMING:\n${i}\n\nOUTGOING:\n${o}\n`], { type: "text/plain" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "scripts-backup.txt";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function resetToDefault() {
    if (!confirm("Сбросить к заводским?")) return;
    try { localStorage.removeItem(KEY_IN); localStorage.removeItem(KEY_OUT); } catch (_) {}
    render("incoming");
    render("outgoing");
    loadIntoEditor();
  }

  document.addEventListener("DOMContentLoaded", () => {
    render("incoming");
    render("outgoing");

    document.querySelectorAll(".tab-btn").forEach(btn => {
      btn.addEventListener("click", () => switchTab(btn.dataset.tab));
    });

    document.getElementById("incoming-search").addEventListener("input", () => render("incoming"));
    document.getElementById("outgoing-search").addEventListener("input", () => render("outgoing"));

    document.querySelectorAll("[data-save]").forEach(btn => {
      btn.addEventListener("click", () => {
        const type = btn.dataset.save;
        const val = document.getElementById(type + "-edit").value;
        if (setRaw(type, val)) {
          render(type);
          alert("Сохранено!");
        } else {
          alert("Не удалось сохранить (localStorage недоступен).");
        }
      });
    });

    document.querySelectorAll("[data-copy]").forEach(btn => {
      btn.addEventListener("click", () => copyBoxText(btn.dataset.copy));
    });

    document.getElementById("download-btn").addEventListener("click", downloadAll);
    document.getElementById("reset-btn").addEventListener("click", resetToDefault);

    document.addEventListener("keydown", (e) => {
      if (e.ctrlKey && e.code === "KeyI") { e.preventDefault(); switchTab("incoming"); }
      if (e.ctrlKey && e.code === "KeyO") { e.preventDefault(); switchTab("outgoing"); }
    });
  });
})();
</script>
</body>
</html>
